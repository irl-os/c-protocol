{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to C-Protocol Documentation","text":"<p>This is the reference repository for the Covenant Protocol (C-Protocol) and the /drop API.</p>"},{"location":"#what-is-c-protocol","title":"What is C-Protocol?","text":"<p>C-Protocol is a meta-protocol for verifiable claim tokens on Bitcoin, enabling private, peer-to-peer exchanges with on-demand settlement.</p>"},{"location":"#explore-the-docs","title":"Explore the Docs","text":"<ul> <li>C-Protocol Overview</li> <li>/drop API Endpoints</li> </ul> <p>For more details, see the README.</p>"},{"location":"c-protocol-overview/","title":"Covenant Protocol (C-Protocol) Specification","text":""},{"location":"c-protocol-overview/#version-information","title":"Version Information","text":"<ul> <li>Version: 0.4.0-draft</li> <li>Status: Working Draft</li> <li>Date: September 10, 2025</li> </ul>"},{"location":"c-protocol-overview/#abstract","title":"Abstract","text":"<p>The Covenant Protocol (C-Protocol) is a universal, platform-agnostic meta-protocol for creating and exchanging verifiable claim tokens that bind digital assets to specific conditions. It leverages the Bitcoin ledger as a truth layer for on-demand settlement, while prioritizing privacy through off-chain negotiation. By combining Party-Defined Proofs from context-specific Proof Authorities with expressive, on-chain covenants, C-Protocol creates a secure bridge between real-world agreements and on-chain state transitions, enabling a peer-to-peer economy of high-trust, programmable value.</p>"},{"location":"c-protocol-overview/#1-introduction-core-principles","title":"1. Introduction &amp; Core Principles","text":""},{"location":"c-protocol-overview/#11-motivation","title":"1.1. Motivation","text":"<p>A significant gap exists in reliably connecting on-chain agreements to off-chain performance and conditions in a private, peer-to-peer manner. C-Protocol is designed to bridge this gap by providing a framework for creating verifiable, transferable claims on assets, where settlement is a final, optional step rather than a prerequisite for exchange.</p>"},{"location":"c-protocol-overview/#12-core-principles","title":"1.2. Core Principles","text":"<ol> <li> <p>Party-Defined Proofs &amp; Conditions: The protocol's integrity rests on conditions and authorities chosen by the covenanting parties. This includes the ability to designate ephemeral, context-specific Proof Authorities (PAs)\u2014such as an event organizer trusted to verify attendance\u2014making the protocol highly adaptable to real-world, time-sensitive agreements.</p> </li> <li> <p>Immutable, On-Demand Settlement: Covenants are Bitcoin Script programs. Their rules are enforced by the Bitcoin mining network, providing finality when settlement is requested. The protocol treats on-chain settlement as a final state transition, not a requirement for every interaction.</p> </li> <li> <p>Privacy Through Off-Chain Negotiation: The exchange of claims and the verification of conditions happen primarily on private, peer-to-peer channels. Only final settlement transactions are broadcast to the public ledger, minimizing the on-chain footprint.</p> </li> <li> <p>Composable &amp; Peer-to-Peer: The protocol is designed for an ecosystem where any peer can be an issuer, holder, or verifier. It extends robust protocols like CAT to allow attested assets to be integrated into a wider ecosystem of decentralized applications.</p> </li> </ol>"},{"location":"c-protocol-overview/#2-architecture-implementation-patterns","title":"2. Architecture &amp; Implementation Patterns","text":"<p>C-Protocol is a layered architecture that supports multiple trust and custody models, allowing developers to choose the right trade-offs for their application.</p> <ul> <li>Layer 1: Truth Layer (Bitcoin Protocol): The ultimate settlement and state machine.</li> <li>Layer 2: Logic Layer (Bitcoin Script / nPrint): The enforcement engine for on-chain settlement.</li> <li>Layer 3: Asset Layer (CAT Protocol): The standard for representing assets governed by covenants.</li> <li>Layer 4: Attestation &amp; Custody Layer: A flexible layer of entities and models for managing assets and verifying proofs.</li> <li>Layer 5: Origination &amp; Negotiation Layer: Where actions occur and claims are exchanged peer-to-peer.</li> </ul>"},{"location":"c-protocol-overview/#21-custody-redemption-models","title":"2.1. Custody &amp; Redemption Models","text":"<p>Peers can implement C-Protocol using various models, ranked by decentralization: 1. Simple Server-Mediated: A single custodian holds assets in escrow. 2. Federated Threshold Custody: An M-of-N quorum of peers manages a threshold wallet. 3. State/Payment Channels: Parties update asset states off-chain with signed messages. 4. Atomic Conditional Releases (Script-based): Primitives like Adaptor Signatures or HTLCs tie asset release atomically to the revelation of a secret.</p>"},{"location":"c-protocol-overview/#3-core-components","title":"3. Core Components","text":""},{"location":"c-protocol-overview/#31-proof-authorities-pas","title":"3.1. Proof Authorities (PAs)","text":"<p>A Proof Authority is any entity\u2014an individual, organization, automated sensor, or software program\u2014that is designated by the covenanting parties to attest to the state of the real world for the purposes of their agreement. The protocol is unopinionated about who can be a PA; the trust is entirely defined by the participants.</p> <ul> <li>Context-Specific: A PA's authority is typically limited to a specific domain. For example, a shipping company's API may be a PA for \"proof of delivery,\" but not for \"proof of identity.\"</li> <li>Ephemeral: A PA's authority can be time-bound. For a beach cleanup, the organizer acts as a PA whose ability to issue valid attendance proofs is only active during the event. This allows for the creation of dynamic, temporary trust relationships that expire safely.</li> </ul>"},{"location":"c-protocol-overview/#32-the-covenant-contract","title":"3.2. The Covenant Contract","text":"<p>A UTXO controlled by a Bitcoin Script program. The script defines the programmable conditions for spending the UTXO.</p>"},{"location":"c-protocol-overview/#321-expressive-conditions","title":"3.2.1. Expressive Conditions","text":"<p>Covenants can implement a rich predicate language for defining unlock conditions. This logic is enforced by the custody model or directly in Bitcoin Script. Examples include: - holder_sig: Requires a valid signature from the claim's holder. - reveal:hash(H): Requires the holder to reveal a secret pre-image x such that SHA256(x) == H. - time_lock:T: The claim is only redeemable after a specific time or block height T. - multi_sig:[pubA, pubB]: Requires signatures from multiple specified parties. - pa_attested:verify_sig(PA_PubKey, proof_data): Requires a valid signature from a designated Proof Authority over specific proof data (e.g., attendance stats).</p>"},{"location":"c-protocol-overview/#33-verifiable-claims-canonical-obligations","title":"3.3. Verifiable Claims (Canonical Obligations)","text":"<p>The core transferable object in the C-Protocol ecosystem is the Canonical Obligation, a signed data structure representing an offer or a finalized receipt. This object is what peers trade.</p> <pre><code>{\n  \"type\": \"offer\" | \"receipt\",\n  \"id\": \"unique_obligation_id\",\n  \"issuer_pub\": \"public_key_of_issuer\",\n  \"holder_pub\": \"public_key_of_current_holder\",\n  \"token_info\": { \"chain\": \"BSV\", \"assetId\": \"...\", \"amount\": 10000 },\n  \"condition_expr\": \"pa_attested:verify_sig(02a4..., 'cleanup_stats')\",\n  \"expiry\": 1757283600,\n  \"nonce\": \"random_bytes\",\n  \"signatures\": [ \"signature_from_issuer\" ]\n}\n</code></pre> <p>This structure allows a claim on an asset to be securely and verifiably transferred between parties off-chain.</p>"},{"location":"c-protocol-overview/#4-protocol-flow-reserve-offer-claim-settle","title":"4. Protocol Flow: Reserve \u2192 Offer \u2192 Claim \u2192 Settle","text":"<ol> <li>Reserve: An Issuer locks an asset using one of the chosen custody models.</li> <li>Offer: The Issuer creates a signed Canonical Obligation of type offer, specifying the conditions for redemption, including any required PA.</li> <li>Claim: A Holder receives the offer. To claim it, they fulfill the condition_expr (e.g., by obtaining a signed attestation from the designated Proof Authority for their cleanup stats) and present this proof to the responsible custody peer(s).</li> <li>Settle: The custody layer verifies the claim and the PA's attestation. Upon success, it either updates its internal off-chain ledger or, if requested, executes the final on-chain settlement.</li> </ol>"},{"location":"c-protocol-overview/#5-privacy-measures","title":"5. Privacy Measures","text":"<ul> <li>Off-Chain First: All negotiation, offers, and claims are exchanged on private, encrypted peer-to-peer channels.</li> <li>On-Demand Settlement: The public blockchain is only used for final settlement.</li> <li>Ephemeral Identifiers &amp; Address Rotation: Peers should use short-lived identifiers and rotate addresses.</li> <li>Batching &amp; Merkle Anchoring: For public verifiability, peers can periodically anchor a single Merkle root of many off-chain obligations to the blockchain.</li> </ul>"},{"location":"c-protocol-overview/#6-security-considerations","title":"6. Security Considerations","text":"<ul> <li>L1 Double-Spend Risk: Each peer should run a lightweight watcher node that monitors the L1 backing UTXOs. If a backing asset is spent, all dependent off-chain obligations must be revoked.</li> <li>Issuer Repudiation: Holders can require offers to be co-signed by a trusted quorum or demand a non-custodial, script-based model.</li> <li>Claim Replay Attacks: Claims must be made single-use through the use of nonces.</li> <li>Peer Collusion / Eclipse Attacks: Clients should connect to a diverse set of independent peer nodes and watchers.</li> </ul>"},{"location":"drop-api-endpoints/","title":"/drop API Specification","text":""},{"location":"drop-api-endpoints/#version-information","title":"Version Information","text":"<ul> <li>Version: 1.2.0</li> <li>Powered by: Covenant Protocol (C-Protocol)</li> </ul>"},{"location":"drop-api-endpoints/#1-overview","title":"1. Overview","text":"<p>The /drop API enables developers to create, exchange, and redeem private, self-custodied digital containers (\"Drops\") that can hold both assets (e.g., BSV, bridged SPL tokens) and arbitrary data payloads (e.g., media, metadata).</p> <p>Each Drop is a C-Protocol covenant. This API specification defines a set of stateless endpoints that any peer can host, allowing Drops to be created, shared offline (via NFC, QR, etc.), and redeemed on the Bitcoin network without reliance on a central server. The state of any Drop can be independently verified by any peer from the on-chain covenant.</p>"},{"location":"drop-api-endpoints/#2-c-protocol-covenant-types","title":"2. C-Protocol Covenant Types","text":"<ul> <li>quick Drop (Proof-of-Possession): A P2PKH script. Unlocked by a signature from the corresponding private key.</li> <li>locked Drop (Proof-of-Knowledge): A hashlock script. Unlocked by the secret pre-image.</li> <li>timed Drop (Proof-of-Time): A time-locked covenant that becomes spendable after a specific block height or time.</li> <li>bridged Drop (Proof-of-Bridged-State): A voucher UTXO requiring a signature from a trusted bridge authority for cross-chain release.</li> </ul>"},{"location":"drop-api-endpoints/#3-authentication-p2p-model","title":"3. Authentication &amp; P2P Model","text":"<p>The API is stateless and non-custodial. All cryptographic signing operations (creating, funding, claiming) are performed client-side. Any participant in the network can run a peer node that hosts these API endpoints to facilitate the exchange of Drops.</p>"},{"location":"drop-api-endpoints/#4-api-endpoints","title":"4. API Endpoints","text":""},{"location":"drop-api-endpoints/#41-create-a-drop","title":"4.1. Create a Drop","text":"<p>POST <code>/api/drop/create</code></p> <p>Initializes a C-Protocol covenant and binds an optional data payload to it.</p> <p>Request Body:</p> <pre><code>{\n  \"senderAddress\": \"1...\",\n  \"assetId\": \"BSV:...\",\n  \"amount\": 50000,\n  \"dropType\": \"locked\",\n  \"proofDefinition\": {\n    \"hash\": \"f2ab34cde...\"\n  },\n  \"payload\": {\n    \"mimeType\": \"image/webp\",\n    \"data\": \"base64-encoded-string-of-payload\",\n    \"size\": 788\n  },\n  \"memo\": \"Avatar + 50,000 sats\"\n}\n</code></pre> <ul> <li>payload (object, optional): An object containing the data to be associated with the Drop. The hash of this payload will be included in the covenant.</li> </ul> <p>Response:</p> <pre><code>{\n  \"dropId\": \"d-93ff8c-...\",\n  \"unsignedTx\": \"01000000...\",\n  \"claimLink\": \"drop://claim/d-93ff8c-...\",\n  \"qrCodeData\": \"drop://claim/d-93ff8c-...\"\n}\n</code></pre> <ul> <li>claimLink (string): A URI using a peer-to-peer schema, allowing any compatible client to handle the claim process.</li> </ul>"},{"location":"drop-api-endpoints/#42-fund-a-drop","title":"4.2. Fund a Drop","text":"<p>POST <code>/api/drop/fund</code></p> <p>Submits the signed transaction to fund the Drop covenant on the Bitcoin ledger.</p> <p>Request Body:</p> <pre><code>{\n  \"dropId\": \"d-93ff8c-...\",\n  \"signedTx\": \"01000000...\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"status\": \"funded\",\n  \"txid\": \"...\",\n  \"covenantUtxo\": { \"txid\": \"...\", \"vout\": 0 }\n}\n</code></pre>"},{"location":"drop-api-endpoints/#43-claim-a-drop","title":"4.3. Claim a Drop","text":"<p>POST <code>/api/drop/claim</code></p> <p>Constructs and broadcasts the transaction to unlock the covenant using the required proof.</p> <p>Request Body:</p> <pre><code>{\n  \"dropId\": \"d-93ff8c-...\",\n  \"recipientAddress\": \"1...\",\n  \"proof\": {\n    \"type\": \"secret\",\n    \"value\": \"hunter2\"\n  }\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"status\": \"claimed\",\n  \"txid\": \"...\",\n  \"assetReleased\": {\n    \"assetId\": \"BSV:...\",\n    \"amount\": 50000\n  }\n}\n</code></pre>"},{"location":"drop-api-endpoints/#44-get-drop-status","title":"4.4. Get Drop Status","text":"<p>GET <code>/api/drop/status/{dropId}</code></p> <p>Retrieves the public state and payload information for a given Drop. A peer can serve this information from its local cache or by inspecting the blockchain.</p> <p>Response:</p> <pre><code>{\n  \"dropId\": \"d-93ff8c-...\",\n  \"status\": \"funded\",\n  \"assetId\": \"BSV:...\",\n  \"amount\": 50000,\n  \"dropType\": \"locked\",\n  \"payload\": {\n    \"mimeType\": \"image/webp\",\n    \"size\": 788,\n    \"hash\": \"sha256:abcd...\"\n  },\n  \"covenant\": {\n    \"script\": \"76a914...\"\n  }\n}\n</code></pre>"},{"location":"drop-api-endpoints/#45-discover-drops","title":"4.5. Discover Drops","text":"<p>GET <code>/api/drop/discover</code></p> <p>Scans the local peer-to-peer network for Drops being broadcast by other nearby peers. This is intended for use with transports like Bluetooth LE, NFC, or local Wi-Fi.</p> <p>Query Parameters: - transport (string, optional): Hint for the desired discovery method (e.g., ble, nfc, local). Defaults to all available. - radius (number, optional): Search radius in meters for location-based transports.</p> <p>Response: A list of publicly broadcasted Drop summaries.</p> <pre><code>[\n  {\n    \"dropId\": \"d-a1b2c3-...\",\n    \"assetId\": \"BSV:...\",\n    \"memo\": \"Coffee fund\",\n    \"peerId\": \"peer-xyz...\"\n  },\n  {\n    \"dropId\": \"d-d4e5f6-...\",\n    \"assetId\": \"SOL:...\",\n    \"memo\": \"USDC for lunch\",\n    \"peerId\": \"peer-abc...\"\n  }\n]\n</code></pre> <ul> <li>peerId (string): An identifier for the peer broadcasting the Drop, which can be used to directly request the Drop status.</li> </ul>"},{"location":"drop-api-endpoints/#5-data-models","title":"5. Data Models","text":""},{"location":"drop-api-endpoints/#drop-object","title":"Drop Object","text":"<p>``` interface Drop {   dropId: string;   status: 'pending' | 'funded' | 'claimed' | 'expired';   assetId: string;   amount: number;   dropType: 'quick' | 'locked' | 'timed' | 'bridged';   covenant: {     script: string;     utxo?: { txid: string; vout: number; };   };   payload?: {     mimeType: string;     size: number;     hash: string; // e.g., \"sha256:abcd...\"   };   bridgeDetails?: {     sourceChain: string;     depositAddress: string;     destinationAddress?: string;   };   createdAt: string;   claimedAt?: string; }</p>"}]}